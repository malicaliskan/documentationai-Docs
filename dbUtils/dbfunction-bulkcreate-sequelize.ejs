<% 
const hasCodename = 

dbObject.properties.some(prop => prop.name == 'codename') && 
(dbObject.properties.some(prop => prop.name == 'name') || 
 dbObject.properties.some(prop => prop.name == 'shortname'));

const baseNameField = hasCodename ? 
  dbObject.properties.find(prop => prop.name == 'shortname')?.name 
    ?? dbObject.properties.find(prop => prop.name == 'name')?.name 
  : null;
%>

const { HttpServerError, BadRequestError } = require("common");
const { ElasticIndexer } = require("serviceCommon");
const { <%= dbObject.modelName %> } = require("models");
const { newUUID } = require("common");

<% if (hasCodename) { -%>
const getNextCodename = async (<%= baseNameField %>) => {
  const getNextCodenameFor<%= dbObject.modelName %> = require("./getNextCodenameFor<%= dbObject.modelName %>.js");
  return await getNextCodenameFor<%= dbObject.modelName %>(<%= baseNameField %>?.toLowerCase());
}
<% } -%>

const indexDataToElastic = async (data) => {
  const elasticIndexer = new ElasticIndexer("<%= dbObject.objectName %>");
  await elasticIndexer.indexData(data);
};

const validateData = (data) => {
  if (!data.id) {
    data.id = newUUID();
  }
};

const createBulk<%= dbObject.modelName %> = async (dataList) => {
  try {
    if (!Array.isArray(dataList) || dataList.length === 0) {
      throw new BadRequestError("Data list must be a non-empty array.");
    }

    const resultList = [];

    for (const data of dataList) {

      <% if (hasCodename) { %>
      if (!data.codename) {
        data.codename = data.<%= baseNameField %>
          ? await getNextCodename(data.<%= baseNameField %>)
          : undefined;
      }
      <% } -%>

      validateData(data);

      const existingDoc = data.id
        ? await <%= dbObject.modelName %>.findByPk(data.id)
        : null;

      let newDoc = null;

      if (existingDoc) {
        delete data.id;
        <% if (dbObject.objectSettings.basicSettings.useSoftDelete) { %>
        data.isActive = true;
        <% } %>
        await existingDoc.update(data);
        newDoc = existingDoc;
      }

      if (!newDoc) {
        newDoc = await <%= dbObject.modelName %>.create(data);
      }

      const _data = newDoc.getData();
      await indexDataToElastic(_data);
      resultList.push(_data);
    }

    return resultList;

  } catch (err) {
    //**errorLog
    throw new HttpServerError(
      "errMsg_dbErrorWhenCreatingBulk<%= dbObject.modelName %>",
      err
    );
  }
};

module.exports = createBulk<%= dbObject.modelName %>;
