<%
// expects: dbObject
const properties = dbObject.properties;
const useSoftDelete = dbObject.objectSettings.basicSettings.useSoftDelete;
const geoPointProps = properties.filter(p => (p.ordType||p.typeName||p.type) === 'GeoPoint');
%>
const { HttpServerError, BadRequestError } = require("common");
const { <%= dbObject.modelName %> } = require("models");

<% for (const gp of geoPointProps) { %>
    
<% const geoField = gp.name; %>
   

// ------------------------------
// GEO HELPERS for <%= dbObject.modelName %>.<%= geoField %>
// ------------------------------

const get<%= dbObject.modelName %>ListInCircle_<%= geoField %> = async (lon, lat, radiusM, query = {}, options = {}) => {
  try {
    if (typeof lon !== 'number' || typeof lat !== 'number' || typeof radiusM !== 'number') {
      throw new BadRequestError("lon, lat, radiusM must be numbers");
    }
    const geoFilter = {
      [ '<%= geoField %>' ]: {
        $nearSphere: {
          $geometry: { type: 'Point', coordinates: [lon, lat] },
          $maxDistance: radiusM
        }
      }
    };

    const where = Object.assign(
      {},
      <% if (useSoftDelete) { %> { isActive: true }, <% } %>
      query || {},
      geoFilter
    );

    const q = <%= dbObject.modelName %>.find(where);
    if (options.limit) q.limit(Number(options.limit));
    if (options.offset) q.skip(Number(options.offset));

    const rows = await q.exec();
    return rows.map(r => r.getData());
  } catch (err) {
    throw new HttpServerError("errMsg_dbErrorWhenRequesting<%= dbObject.modelName %>ListInCircle", err);
  }
};

const get<%= dbObject.modelName %>ListMostClose_<%= geoField %> = async (lon, lat, limit = 10, query = {}, options = {}) => {
  try {
    if (typeof lon !== 'number' || typeof lat !== 'number') {
      throw new BadRequestError("lon, lat must be numbers");
    }
    const geoFilter = {
      [ '<%= geoField %>' ]: {
        $nearSphere: {
          $geometry: { type: 'Point', coordinates: [lon, lat] },
          ...(options.radiusM ? { $maxDistance: Number(options.radiusM) } : {})
        }
      }
    };

    const where = Object.assign(
      {},
      <% if (useSoftDelete) { %> { isActive: true }, <% } %>
      query || {},
      geoFilter
    );

    const rows = await <%= dbObject.modelName %>
      .find(where)
      .limit(Number(limit) || 10)
      .skip(options.offset ? Number(options.offset) : 0)
      .exec();

    return rows.map(r => r.getData());
  } catch (err) {
    throw new HttpServerError("errMsg_dbErrorWhenRequesting<%= dbObject.modelName %>ListMostClose", err);
  }
};

const get<%= dbObject.modelName %>ListInBBox_<%= geoField %> = async (minLon, minLat, maxLon, maxLat, query = {}, options = {}) => {
  try {
    [minLon, minLat, maxLon, maxLat].forEach(v => { if (typeof v !== 'number') throw new BadRequestError("BBox values must be numbers"); });

    const geoFilter = {
      [ '<%= geoField %>' ]: {
        $geoWithin: { $box: [[minLon, minLat], [maxLon, maxLat]] }
      }
    };

    const where = Object.assign(
      {},
      <% if (useSoftDelete) { %> { isActive: true }, <% } %>
      query || {},
      geoFilter
    );

    const q = <%= dbObject.modelName %>.find(where);
    if (options.limit) q.limit(Number(options.limit));
    if (options.offset) q.skip(Number(options.offset));

    const rows = await q.exec();
    return rows.map(r => r.getData());
  } catch (err) {
    throw new HttpServerError("errMsg_dbErrorWhenRequesting<%= dbObject.modelName %>ListInBBox", err);
  }
};

module.exports.get<%= dbObject.modelName %>ListInCircle_<%= geoField %> = get<%= dbObject.modelName %>ListInCircle_<%= geoField %>;
module.exports.get<%= dbObject.modelName %>ListMostClose_<%= geoField %> = get<%= dbObject.modelName %>ListMostClose_<%= geoField %>;
module.exports.get<%= dbObject.modelName %>ListInBBox_<%= geoField %> = get<%= dbObject.modelName %>ListInBBox_<%= geoField %>;

<% } // end for each geo prop %>
