---
title: Writing Your Own Code in Mindbricks
description: >-
  Most of your backend is defined through patterns (DataObject, BusinessApi,
  Service, ProjectAuthentication, etc.) and generated automatically.

  However, real-world systems always have edge cases‚Äîbusiness rules,
  transformations, integrations, or performance hacks that can‚Äôt (and shouldn‚Äôt)
  be fully captured by declarative patterns alone.
---
Mindbricks is **declarative-first**, but it is not a closed box.

This document explains how to extend Mindbricks with **custom code** in three main ways:

1. **MScript** ‚Äì Inline JavaScript expressions embedded in pattern fields.

2. **Service Library** ‚Äì Reusable JS modules, templates, and assets inside `ServiceLibrary`.

3. **Edge Controllers** ‚Äì Fully custom HTTP endpoints backed by edge functions.

The goal is to help both **human architects** and **AI agents** confidently answer the question:

The answer is: **Yes. Always.** You just choose the right level of extension.

---

## 1. Three Layers of Custom Code

Before diving into details, it‚Äôs helpful to see the three main extension layers side by side.

```plaintext
1. MScript         ‚Äì Lightweight, inline expressions & queries inside patterns.
2. Service Library ‚Äì Reusable functions, templates, assets, public files per service.
3. Edge Controllers‚Äì Full-control routes mapped to custom JS handlers.
```

### When to Use Which?

- **MScript**
  Use when you can express the logic as an expression, a query, or a small function call:

  - where clauses

  - access checks

  - formulas & derived fields

  - building queries or payloads

  - mapping and filtering lists

- **Service Library**
  Use when logic is a bit larger or shared:

  - utility functions for price, tax, scoring, etc.

  - building complex MScript Query objects

  - calling external APIs with shared logic

  - complex string building (logs, messages)

  - implementing a small rules engine

- **Edge Controllers**
  Use when you need full control:

  - very custom HTTP endpoints

  - multi-step integrations that don‚Äôt map nicely to a BusinessApi

  - admin/maintenance tools

  - specialized export/import endpoints

  - very custom workflows where you want to write ‚Äúplain‚Äù Node.js logic

All three are **compatible** with the declarative patterns. You don‚Äôt leave Mindbricks‚Äîyou extend it from inside.

---

## 2. MScript ‚Äì Inline, Context-Aware Expressions

### 2.1 What Is MScript?

In the Mindbricks ontology, `MScript` is a special **string-based type** that stores JavaScript expressions.

```json
{
  "MScript": {
    "__isStringType": true
  }
}
```

MScript is used across many patterns:

- `DataMapItem.value`

- `PropertyFormulaSettingsConfig.formula` & `updateFormula`

- `WhereClauseSettings.fullWhereClause`

- `ExtendedClause.doWhen`, `excludeWhen`, `whereClause`

- `VerificationConfig.verificationTemplate` (rendering context)

- `StripeOrderConfig.amount`, `description`

- `BusinessApiAction.condition`

- Actions like `FunctionCallAction.callScript`, `FetchObjectAction.matchValue`, `ListMapAction.mapScript`, `IntegrationParameter.parameterValue`, `ValidationAction.validationScript`, and many more.

MScript lets you ‚Äúdrop‚Äù logic into the generated code, while Mindbricks manages structure, lifecycle, and context.

### 2.2 First Rule

MScript values are injected directly into generated code after syntax validation. A good rule of thumb:

Example in design:

```json
{
  "condition": "this.user.age > 18"
}
```

Mindbricks might generate code like:

```js
const condition = this.user.age > 18;
if (!condition) {
  throw new Error("User should be older than 18");
}
```

If you‚Äôre unsure, you can always wrap your expression with `module.exports`:

```js
module.exports = (this.user.age > 18)
```

Mindbricks will extract the exported expression.

### 2.3 The Context: `this`

Most MScript runs inside a **Business API manager class**. In that scope, `this` is the runtime context.

Common things you can access:

- **Business API parameters**

  ```javascript
  this.productId
  this.searchKeyword
  ```

- **Session data**

  ```javascript
  this.session.userId
  this.session.roleId
  this.session.tenantId
  ```

- **Main data object instance(s)**
  Depending on crudType:

  - `create` / `get` / `update` / `delete`: `this.customer`, `this.order`, etc.

  - `list`: `this.customers`, `this.orders` (plural list).

- **Action outputs** (from `BusinessApiAction` with `contextPropertyName`)

  ```js
  // Example: FetchObjectAction with contextPropertyName = "userCompany"
  this.userCompany.name
  ```

- **Library functions** via `LIB`

  ```javascript
  LIB.common.md5(this.email ?? "nullValue")
  LIB.getSearchQueryForProduct(this.keyword)
  ```

- **Other context fields** added by `AddToContextAction` or `CreateObjectAction`.

Keeping this mental model makes MScript much more intuitive.

### 2.4 MScript Examples by Use Case

#### 2.4.1 Conditional Checks

You want to ensure the current user owns the resource:

```json
{
  "condition": "this.customer.userId === this.session.userId"
}
```

Used in:

- `ValidationAction.validationScript`

- `ExtendedClause.doWhen`

- `MembershipCheckAction.checkFor`

#### 2.4.2 Dynamic Formula

A `totalPrice` property as `unitPrice * quantity`:

```json
{
  "formulaSettings": {
    "isCalculated": true,
    "configuration": {
      "formula": "this.unitPrice * this.quantity"
    }
  }
}
```

This is placed under a `DataProperty`‚Äôs `formulaSettings` for that field.

#### 2.4.3 Inline Arrow Function for Complex Logic

Sometimes you need a few steps:

```json
{
  "formula": "(() => { const net = this.grossAmount - this.discountAmount; return Math.max(net, 0); })()"
}
```

#### 2.4.4 MScript Query (Where Clause)

Filtering orders for the current user:

```json
{
  "fullWhereClause": "({ userId: { \"$eq\": this.session.userId } })"
}
```

Using the MScript Query syntax, you can also do more complex filters:

```json
{
  "fullWhereClause": "({ \"$and\": [ { status: { \"$eq\": 'published' } }, { tenantId: { \"$eq\": this.session.tenantId } } ] })"
}
```

Mindbricks converts this unified syntax into SQL/Sequelize, MongoDB, or Elasticsearch queries depending on deployment.

#### 2.4.5 Building Queries via Library Functions

```js
// In service library functions
const getSearchQueryForProduct = (pName) => {
  return { name: { "$ilike": `%${pName}%` } };
};

module.exports = getSearchQueryForProduct;
```

Used in a BusinessApi where clause:

```json
{
  "fullWhereClause": "LIB.getSearchQueryForProduct(this.productName)"
}
```

This is a perfect example of **MScript + Library** working together.

---

## 3. Service Library ‚Äì Your Private Utility Toolbox

Patterns: `ServiceLibrary`, `LibModule`

Every service has a `library` field:

```json
{
  "library": {
    "functions": [ /* LibModule */ ],
    "edgeFunctions": [ /* LibModule */ ],
    "templates": [ /* LibModule */ ],
    "assets": [ /* LibModule */ ],
    "public": [ /* LibModule */ ]
  }
}
```

Each `LibModule` has:

- `moduleName` ‚Äì unique name within the library

- `moduleExtension` ‚Äì e.g. `js`, `ejs`, `txt`, `svg`, `pdf`

- `moduleBody` ‚Äì the source code/content (string)

This is where you write **real code**:

- shared validation functions

- calculators (price, tax, commissions)

- query builders

- AI prompt builders

- integration wrappers

- document templates and static assets

### 3.1 Functions ‚Äì Reusable Business Logic

**Use case examples:**

- Normalize product names.

- Calculate totals and discounts.

- Generate a standard search query.

- Validate country-specific ID numbers.

- Map external statuses to internal ones.

**Example: version sorter**

```json
{
  "library": {
    "functions": [
      {
        "moduleName": "sortVersions",
        "moduleExtension": "js",
        "moduleBody": "module.exports = function sortVersions(versions) {\n  return versions.sort((a, b) => {\n    const partsA = a.split('.').map(Number);\n    const partsB = b.split('.').map(Number);\n    const maxLength = Math.max(partsA.length, partsB.length);\n    for (let i = 0; i < maxLength; i++) {\n      const numA = partsA[i] || 0;\n      const numB = partsB[i] || 0;\n      if (numA > numB) return 1;\n      if (numA < numB) return -1;\n    }\n    return 0;\n  });\n}"
      }
    ]
  }
}
```

Use it in MScript:

```json
{
  "callScript": "LIB.sortVersions(this.versionList)"
}
```

Or use it to compute derived data in a `FunctionCallAction` or `AddToContextAction`.

#### Real-Life Case: Shipping Fee Calculation

```json
{
  "library": {
    "functions": [
      {
        "moduleName": "calculateShippingFee",
        "moduleExtension": "js",
        "moduleBody": "module.exports = function calculateShippingFee(order) {\n  const base = 5;\n  const weight = order.totalWeight || 0;\n  const distanceFactor = order.distanceKm || 0;\n  return base + weight * 0.5 + distanceFactor * 0.1;\n}"
      }
    ]
  }
}
```

Then in a `DataProperty` formula for `shippingFee`:

```json
{
  "formulaSettings": {
    "isCalculated": true,
    "configuration": {
      "formula": "LIB.calculateShippingFee(this.order)"
    }
  }
}
```

Best of both worlds: pattern-driven property + custom calculation logic.

#### Passing Business API Context into Library Functions

Library functions can use any signature you design. If you need access to the Business API runtime context (`this`), explicitly receive it as an argument (recommended name: `context`) and pass `this` when you call the function.

**Library function that expects context:**

```json
{
  "moduleName": "calculateOffer",
  "moduleExtension": "js",
  "moduleBody": "module.exports = function calculateOffer(context, order) {\n  const locale = context.session?.locale ?? 'en';\n  const tenant = context.session?.tenantId;\n  const base = order.subtotal ?? 0;\n  const discount = context.user?.loyaltyLevel === 'gold' ? 0.1 : 0;\n  return { total: Math.max(base * (1 - discount), 0), locale, tenant };\n}"
}
```

**Call it inside an action (MScript area of a `FunctionCallAction`):**

```json
{
  "actions": {
    "functionCallActions": [
      {
        "extendClassName": "FunctionCallAction",
        "name": "computeOffer",
        "callScript": "LIB.calculateOffer(this, this.order)",
        "contextPropertyName": "offer"
      }
    ]
  }
}
```

**Use it inline in other MScript fields (e.g., a condition):**

```json
{
  "condition": "LIB.calculateOffer(this, this.order).total > 0"
}
```

The key pattern: **design the signature, accept `context`, and pass `this`** wherever you need runtime data from the API in your library code.

### 3.2 Edge Functions ‚Äì Custom Route Handlers

`edgeFunctions` are used by `EdgeController` and must export an async function:

```json
{
  "library": {
    "edgeFunctions": [
      {
        "moduleName": "helloWorld",
        "moduleExtension": "js",
        "moduleBody": "module.exports = async (request) => {\n  return { status: 200, message: 'Hello from the edge function', now: new Date().toISOString() };\n};"
      }
    ]
  }
}
```

We‚Äôll dive into edge controllers in the next section, but keep in mind: **this is where their logic lives**.

### 3.3 Templates ‚Äì Dynamic Content

Use `templates` with `RenderDataAction` or other rendering logic.

**Use case examples:**

- Welcome email

- Payment receipt

- Multi-language document

- HTML snippet for PDF export

```json
{
  "library": {
    "templates": [
      {
        "moduleName": "orderInvoiceHtml",
        "moduleExtension": "ejs",
        "moduleBody": "<html><body><h1>Invoice #<%= order.id %></h1><p>Total: <%= order.totalAmount %> <%= order.currency %></p></body></html>"
      }
    ]
  }
}
```

Then:

```json
{
  "actions": {
    "renderDataActions": [
      {
        "extendClassName": "RenderDataAction",
        "name": "renderInvoice",
        "template": "orderInvoiceHtml",
        "inputData": "{ order: this.order }",
        "contextPropertyName": "invoiceHtml",
        "writeToResponse": false
      }
    ],
    "dataToFileActions": [
      {
        "extendClassName": "DataToFileAction",
        "name": "exportInvoicePdf",
        "inputData": "this.invoiceHtml",
        "outputFormat": "pdf",
        "sendToClient": true
      }
    ]
  }
}
```

### 3.4 Assets and Public Files

- `assets`: internal text/binary data (stored as text in `moduleBody`)

- `public`: static assets exposed via HTTP (logos, favicons, PDFs, static docs)

Examples:

```json
{
  "library": {
    "assets": [
      {
        "moduleName": "awsCredentials",
        "moduleExtension": "txt",
        "moduleBody": "AWS_ACCESS_KEY_ID=...\nAWS_SECRET_ACCESS_KEY=..."
      }
    ],
    "public": [
      {
        "moduleName": "favicon",
        "moduleExtension": "png",
        "moduleBody": "<base64-image-data>"
      }
    ]
  }
}
```

Then, internal code can read `awsCredentials` via special asset loader, while `favicon` is served via a static route.

---

## 4. Edge Controllers ‚Äì ‚ÄúThere Is Always a Route‚Äù

Patterns: `EdgeController`, `EdgeControllerOptions`, `EdgeRestSettings`, `ServiceLibrary.edgeFunctions`

Sometimes you need to go beyond BusinessApi workflows and auto-generated routes:

- A **maintenance endpoint** to trigger a re-indexing job.

- A **special integration** that aggregates multiple external APIs and returns a custom response.

- A **migration tool** exposed temporarily for controlled admin use.

- A **custom webhook handler** not yet covered by native integrations.

- A **debug endpoint** for introspecting specific state in controlled environments.

This is where **Edge Controllers** shine.

### 4.1 How Edge Controllers Work

An `EdgeController` ties a URL + HTTP method to an edge function:

```json
{
  "edgeControllers": [
    {
      "edgeControllerOptions": {
        "functionName": "sendMail",
        "loginRequired": true
      },
      "edgeRestSettings": {
        "path": "/sendmail",
        "method": "POST"
      }
    }
  ]
}
```

- `edgeControllerOptions.functionName` ‚Üí `library.edgeFunctions[].moduleName`

- `edgeControllerOptions.loginRequired` ‚Üí whether to enforce session/auth

- `edgeRestSettings.path` ‚Üí exposed REST path

- `edgeRestSettings.method` ‚Üí HTTP method (from `HTTPRequestMethods`)

Edge function example:

```json
{
  "library": {
    "edgeFunctions": [
      {
        "moduleName": "sendMail",
        "moduleExtension": "js",
        "moduleBody": "const { sendSmtpEmail } = require('common');\n\nmodule.exports = async (request) => {\n  const { to, subject, text } = request.body;\n  const emailFrom = request.session?.email ?? 'noreply@myapp.com';\n\n  await sendSmtpEmail({ emailFrom, to, subject, text });\n\n  return {\n    status: 201,\n    message: 'Email sent',\n    date: new Date().toISOString()\n  };\n};"
      }
    ]
  }
}
```

From the client‚Äôs perspective, this looks like any other endpoint:

```text
POST /sendmail
Content-Type: application/json

{
  "to": "user@example.com",
  "subject": "Hello",
  "text": "Welcome to our service!"
}
```

### 4.2 Real-Life Edge Controller Scenarios

#### 4.2.1 Custom Reporting Endpoint

You want a `/admin/export-users` endpoint that:

1. Fetches users with specific filters

2. Generates a CSV

3. Returns it as a downloadable file

You might choose an Edge Controller because:

- You want full flexibility over the CSV format.

- You may need to call multiple services.

- You might use Node streams or large-memory operations.

Edge function:

```js
// moduleName: exportUsersCsv
module.exports = async (request) => {
  const { role, since } = request.query;
  const users = await request.services.auth.getUsers({ role, since });

  const header = "id,email,role\n";
  const rows = users.map(u => `${u.id},${u.email},${u.roleId}`).join("\n");
  const csv = header + rows + "\n";

  return {
    status: 200,
    headers: {
      "Content-Type": "text/csv",
      "Content-Disposition": "attachment; filename=\"users.csv\""
    },
    body: csv
  };
};
```

Edge controller:

```json
{
  "edgeControllers": [
    {
      "edgeControllerOptions": {
        "functionName": "exportUsersCsv",
        "loginRequired": true
      },
      "edgeRestSettings": {
        "path": "/admin/export-users",
        "method": "GET"
      }
    }
  ]
}
```

#### 4.2.2 External System Sync

You need to call a legacy SOAP API, combine it with local DB data, and return a derived result:

- Patterns handle 95% of your CRUD.

- For this one special case, you create an Edge Controller.

The edge function can:

- Read query/body

- Use `request.services` to call internal Business APIs

- Use any Node.js library you added via `nodejsPackages`

- Perform a custom algorithm

- Return the response you want

This gives you **escape hatches** without breaking the Mindbricks structure.

---

## 5. Importing Internal Mindbricks Libraries (`common`, `serviceCommon`, `dbLayer`, `models`)

When writing custom logic inside your **service library**, **edge controllers**, or **MScript-powered functions**, you are not limited to raw JavaScript. Every Mindbricks service includes a set of **internal libraries**‚Äîautomatically generated or shared‚Äîthat encapsulate common infrastructure, data access, and service behaviors.

These libraries are globally available in every service at runtime and can be imported directly:

```js
const COMMON = require("common");
const SERVICE_COMMON = require("serviceCommon");
const DB = require("dbLayer");
const MODELS = require("models");
```

No relative paths are required‚ÄîMindbricks injects these libraries into the service environment in a standardized manner.

---

### **1.&#x20;****`common`****&#x20;‚Äî Shared Infrastructure Utilities (Project-Wide)**

The **`common`** library is identical across all services in the project. It contains production-ready, low-level utilities that would otherwise require thousands of lines of handwritten infrastructure code.

Common categories include:

#### **üîê Crypto & Token Utilities**

- `createJWT`, `validateJWT`

- RSA variants: `createJWT_RSA`, `validateJWT_RSA`

- Token encoding/decoding: `encodeToken`, `decodeToken`

- Hashing utilities: `hashString`, `hashCompare`, `md5`, `intHash`

- OTP generator: `randomCode`



**üóÑ  Redis Cache**

- &#x20;`redisClient`

- `getRedisData`, `setRedisData`



#### **ü¶Ñ Elasticsearch / CQRS**

- `ElasticIndexer`

- &#x20;`elasticClient`



#### **üì® Messaging & Events (Kafka)**

- `sendMessageToKafka`



#### **üåê External HTTP / File Retrieval**

- `getRestData`, `sendRestRequest`, `downloadFile`

####



#### **üõ† Utility Helpers**

- UUID/ObjectID helpers: `newUUID`, `shortUUID`, `newObjectId`, `isValidUUID`

- Array utilities: `concatListResults`, `mapArrayItems`

- Query builders: `buildSequelizeClause`, `buildMongooseClause, buildElasticClause`

- Logging: `hexaLogger`, `HexaLogTypes`

---

### **2.&#x20;****`serviceCommon`****&#x20;‚Äî Helpers Specific to the Current Service**

Unlike `common`, which is universal, **`serviceCommon`** is generated specifically for the current service. It contains service-level helpers that adapt to the service‚Äôs domain.



#### **üì° ServicePublisher**

Used to publish events from this service to Kafka. The difference of this service publisher from the common `sendMessageToKafka` is that, this one can attach current users session to the message, so any login required route that has a kafka controller listening to the topic will be able to use the publisher user's session.

```js
const { ServicePublisher } = require("serviceCommon");

await ServicePublisher.publish("order.created", {
  orderId: order.id,
  userId: order.userId
});
```



#### **üìä ElasticIndexer**



#### Manages Elasticsearch indexes to index data, search data, update data etc.

```javascript
const { ElasticIndexer } = require("serviceCommon");
const indexer = new ElasticIndexer("order");
await indexer.indexData({...});
```

### **3.&#x20;****`dbLayer`****&#x20;‚Äî Generated DB Layer Functions Based on Your DataObjects**

Every service has a generated **data-access layer** (`dbLayer`), which provides formally defined CRUD, query, and aggregation helpers derived from your `DataObject` patterns.

**Important:** Always use `dbLayer` functions instead of directly accessing models. These utility functions ensure data consistency between the database, Elasticsearch, and Kafka events triggered on database changes.

Example imports:

```js
// Using destructuring (recommended)
const { getUserById, createUser } = require("dbLayer");

// Or using the full module
const DB = require("dbLayer");
```

For each data object in your service, Mindbricks automatically generates the following utility functions (where `ModelName` is the PascalCase name of your data object):

#### **Create Functions**

- **`create${ModelName}(data, context)`** ‚Äî Creates a single record
  - **Parameters:** 
    - `data` (Object) ‚Äî The data object to create. If `id` is provided and exists, it will update the existing record instead.
    - `context` (Object, optional) ‚Äî Context object with `session` and `requestId`. When called from Business API actions, pass `this`.
  - **Returns:** Object ‚Äî The created/updated record data
  - **Auto-handles:** ID generation (if not provided), codename generation (if applicable), Elasticsearch indexing, Kafka events

- **`createBulk${ModelName}(dataList, context)`** ‚Äî Creates multiple records in bulk
  - **Parameters:** 
    - `dataList` (Array) ‚Äî Array of data objects to create
    - `context` (Object, optional) ‚Äî Context object with `session` and `requestId`. When called from Business API actions, pass `this`.
  - **Returns:** Array ‚Äî Array of created/updated record data
  - **Auto-handles:** Same as single create, uses optimized bulk operations

#### **Read Functions**

- **`get${ModelName}ById(id)`** ‚Äî Retrieves a record by ID
  - **Parameters:** `id` (String|Array) ‚Äî Single ID or array of IDs
  - **Returns:** Object|Array|null ‚Äî Single record, array of records, or null if not found
  - **Respects:** Soft delete settings (only returns active records if soft delete is enabled)

- **`get${ModelName}AggById(id)`** ‚Äî Retrieves a record with aggregated/joined data
  - **Parameters:** `id` (String|Array) ‚Äî Single ID or array of IDs
  - **Returns:** Object|Array|null ‚Äî Record(s) with joined relations populated via CQRS joins
  - **Use case:** When you need related data from other services

- **`get${ModelName}ListByQuery(query)`** ‚Äî Retrieves multiple records matching a query
  - **Parameters:** `query` (Object) ‚Äî Sequelize or MongoDB query object (depending on your DB type)
  - **Returns:** Array ‚Äî Array of matching records (empty array if none found)
  - **Respects:** Soft delete settings

- **`get${ModelName}ByQuery(query)`** ‚Äî Retrieves a single record matching a query
  - **Parameters:** `query` (Object) ‚Äî Sequelize or MongoDB query object
  - **Returns:** Object|null ‚Äî First matching record (ordered by createdAt DESC) or null
  - **Respects:** Soft delete settings

- **`get${ModelName}StatsByQuery(query, stats)`** ‚Äî Calculates statistics on matching records
  - **Parameters:** 
    - `query` (Object) ‚Äî Sequelize or MongoDB query object
    - `stats` (Array|String) ‚Äî Array of stat operations (e.g., `["count", "sum(amount)", "avg(price)", "min(price)", "max(price)"]`) or single stat string
  - **Returns:** Number|Object ‚Äî Single stat value or object with stat labels as keys
  - **Example:** `await DB.getOrderStatsByQuery({ status: "paid" }, ["count", "sum(totalAmount)"])` returns `{ count: 10, "sum-totalAmount": 5000 }`

- **`getIdListOf${ModelName}ByField(fieldName, fieldValue, isArray)`** ‚Äî Gets list of IDs matching a field value
  - **Parameters:**
    - `fieldName` (String) ‚Äî Field name to match
    - `fieldValue` (Any) ‚Äî Value to match
    - `isArray` (Boolean) ‚Äî If true, uses array containment check (for array fields)
  - **Returns:** Array ‚Äî Array of IDs matching the criteria
  - **Use case:** Quick ID lookups for building relationships or filters

#### **Update Functions**

- **`update${ModelName}ById(id, dataClause, context)`** ‚Äî Updates a record by ID
  - **Parameters:**
    - `id` (String|Object) ‚Äî Record ID or object with `id` property
    - `dataClause` (Object) ‚Äî Fields to update (if `id` is object, can be omitted)
    - `context` (Object, optional) ‚Äî Context object with `session` and `requestId`. When called from Business API actions, pass `this`.
  - **Returns:** Object ‚Äî Updated record data
  - **Auto-handles:** Elasticsearch indexing, Kafka events, soft delete checks

- **`update${ModelName}ByIdList(idList, dataClause, context)`** ‚Äî Updates multiple records by ID list
  - **Parameters:**
    - `idList` (Array) ‚Äî Array of IDs to update
    - `dataClause` (Object) ‚Äî Fields to update for all records
    - `context` (Object, optional) ‚Äî Context object with `session` and `requestId`. When called from Business API actions, pass `this`.
  - **Returns:** Array ‚Äî Array of updated record IDs
  - **Auto-handles:** Elasticsearch indexing for all updated records

- **`update${ModelName}ByQuery(query, dataClause, context)`** ‚Äî Updates all records matching a query
  - **Parameters:**
    - `query` (Object) ‚Äî Sequelize or MongoDB query object
    - `dataClause` (Object) ‚Äî Fields to update
    - `context` (Object, optional) ‚Äî Context object with `session` and `requestId`. When called from Business API actions, pass `this`.
  - **Returns:** Array ‚Äî Array of updated record data
  - **Auto-handles:** Elasticsearch indexing for all updated records

#### **Delete Functions**

- **`delete${ModelName}ById(id, context)`** ‚Äî Deletes a record by ID
  - **Parameters:** 
    - `id` (String|Object) ‚Äî Record ID or object with `id` property
    - `context` (Object, optional) ‚Äî Context object with `session` and `requestId`. When called from Business API actions, pass `this`.
  - **Returns:** Object ‚Äî Deleted record data
  - **Auto-handles:** Soft delete (if enabled), Elasticsearch deletion, Kafka events

- **`delete${ModelName}ByQuery(query, context)`** ‚Äî Deletes all records matching a query
  - **Parameters:** 
    - `query` (Object) ‚Äî Sequelize or MongoDB query object
    - `context` (Object, optional) ‚Äî Context object with `session` and `requestId`. When called from Business API actions, pass `this`.
  - **Returns:** Array ‚Äî Array of deleted record data
  - **Auto-handles:** Soft delete (if enabled), Elasticsearch deletion for all records

#### **Query Format**

All functions that accept a `query` parameter use the same format as your selected database type:

- **Sequelize (PostgreSQL, MySQL, etc.):** Standard Sequelize query syntax
  ```js
  { status: "active", age: { [Op.gte]: 18 } }
  ```

- **MongoDB:** Standard MongoDB query syntax
  ```js
  { status: "active", age: { $gte: 18 } }
  ```

#### **Why Use dbLayer Instead of Direct Model Access?**

These functions provide a **safe, typed, generated repository layer** that:

- ‚úÖ **Ensures data consistency** ‚Äî Automatically syncs with Elasticsearch
- ‚úÖ **Triggers events** ‚Äî Publishes Kafka events on data changes
- ‚úÖ **Respects constraints** ‚Äî Applies soft deletes, multitenancy, and access control
- ‚úÖ **Normalizes results** ‚Äî Returns consistent data structures via `getData()`
- ‚úÖ **Handles edge cases** ‚Äî Manages codename generation, ID creation, etc.
- ‚úÖ **Minimizes errors** ‚Äî Reduces the need for raw ORM access and potential inconsistencies

**Example usage in a library function:**

```js
const { getOrderAggById, updateOrderById, getItemListByQuery, getOrderStatsByQuery } = require("dbLayer");

// If called from Business API action, receive context and pass it through
module.exports = async function processOrder(orderId, context = null) {
  // Get order with aggregated data
  const order = await getOrderAggById(orderId);
  if (!order) throw new Error("Order not found");
  
  // Update order status (pass context for event tracking)
  await updateOrderById(orderId, { status: "processed" }, context);
  
  // Get related items
  const items = await getItemListByQuery({ orderId: orderId });
  
  // Calculate total
  const stats = await getOrderStatsByQuery(
    { orderId: orderId },
    ["sum(amount)"]
  );
  
  return { order, items, total: stats["sum-amount"] };
};

// When called from a Business API action:
// LIB.processOrder(this.orderId, this)
```

### **4.&#x20;****`models`****&#x20;‚Äî Raw ORM Models (Advanced Only)**

Finally, the **`models`** library gives you direct access to Sequelize or Mongoose models for the service:

```js
const MODELS = require("models");

// Example:
const { User, UserGroup } = MODELS;
```

This gives you **full control**, but also full responsibility:

```js
const admins = await MODELS.User.findAll({
  where: { roleId: "admin" },
  limit: 50
});
```

This is powerful for:

- Custom aggregation queries

- Service-level patches or migrations

- Temporary or emergency tooling

But note:

- It bypasses BusinessApi validations

- It bypasses access control layers

- It may break invariants if misused

**Please check common libraries reference document to get complete information for  all importable function and class.**

## 6. Pattern + Code: Always a Solution

It‚Äôs easy to fall into two extremes:

- ‚ÄúEverything must be declarative; no code.‚Äù

- ‚ÄúEverything must be code; patterns get in the way.‚Äù

Mindbricks is designed to sit **between** these: patterns for structure, **code where it matters**.

### 6.1 A Typical Design Journey

1. **Start with patterns**
   Model your domain via `DataObject`, `BusinessApi`, `AccessControl`, etc.

2. **Use MScript liberally**
   Add MScript conditions, formulas, where clauses, map functions, and function calls.

3. **Factor out complexity into the Service Library**
   When an MScript expression becomes too complex or is reused in multiple places:

   - Move the heavy logic into a `functions` module.

   - Call it via `LIB.someFunction(...)` in MScript.

4. **Use Edge Controllers for truly custom flows**
   When a whole route‚Äôs behavior does not fit a BusinessApi pattern:

   - Create a small `edgeFunctions` module.

   - Expose it via an `EdgeController` path and method.

   - Keep using patterns elsewhere.

### 6.2 Decision Hints

- **Can it be expressed as a pure expression or query?** ‚Üí MScript.

- **Is the logic reused in several places or growing in size?** ‚Üí Service Library function.

- **Does it require full control over request/response or multi-service orchestration?** ‚Üí Edge Controller.

### 6.3 Philosophical Note

The combination of:

- strong **ontology** (patterns),

- flexible **expressions** (MScript),

- and precise **code anchors** (Service Library & Edge Controllers),

makes Mindbricks less like a rigid code generator and more like a **language for backend architecture**‚Äîwhere you can always ‚Äúdrop down‚Äù one level to express what you need, without losing the benefits of structure, documentation, and automation.

There is always a route:

- If it‚Äôs small ‚Üí MScript.

- If it‚Äôs shared ‚Üí Library.

- If it‚Äôs a one-off but important endpoint ‚Üí Edge Controller.

You stay *inside* Mindbricks, but you are never trapped by it.
